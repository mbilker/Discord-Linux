{
  "_args": [
    [
      "erlpack@git+https://github.com/hammerandchisel/erlpack.git",
      "/home/mbilker/discord-linux"
    ]
  ],
  "_from": "git+https://github.com/hammerandchisel/erlpack.git",
  "_id": "erlpack@0.1.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/erlpack",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/hammerandchisel/erlpack/master/package.json",
      "gitUrl": "git://github.com/hammerandchisel/erlpack.git",
      "httpsUrl": "git+https://github.com/hammerandchisel/erlpack.git",
      "shortcut": "github:hammerandchisel/erlpack",
      "ssh": "git@github.com:hammerandchisel/erlpack.git",
      "sshUrl": "git+ssh://git@github.com/hammerandchisel/erlpack.git",
      "type": "github"
    },
    "name": "erlpack",
    "raw": "erlpack@git+https://github.com/hammerandchisel/erlpack.git",
    "rawSpec": "git+https://github.com/hammerandchisel/erlpack.git",
    "scope": null,
    "spec": "git+https://github.com/hammerandchisel/erlpack.git",
    "type": "hosted"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git+https://github.com/hammerandchisel/erlpack.git#433cfe5cb593668272801fd26635174084b29447",
  "_shasum": "a8a566477db9f49e84e3189dbe9172c1bc55abf0",
  "_shrinkwrap": null,
  "_spec": "erlpack@git+https://github.com/hammerandchisel/erlpack.git",
  "_where": "/home/mbilker/discord-linux",
  "author": {
    "name": "Jason Citron"
  },
  "bugs": {
    "url": "https://github.com/hammerandchisel/erlpack/issues"
  },
  "dependencies": {
    "bindings": "^1.2.1",
    "nan": "^2.1.0"
  },
  "description": "Erlpack is a fast encoder and decoder for the Erlang Term Format (version 131) for Javascript",
  "devDependencies": {
    "babel-jest": "^6.0.1",
    "jest-cli": "^0.8.2"
  },
  "gitHead": "433cfe5cb593668272801fd26635174084b29447",
  "gypfile": true,
  "homepage": "https://github.com/hammerandchisel/erlpack#readme",
  "jest": {
    "scriptPreprocessor": "<rootDir>/node_modules/babel-jest",
    "unmockedModulePathPatterns": [
      "<rootDir>/build",
      "<rootDir>/node_modules/bindings"
    ]
  },
  "license": "Apache-2.0",
  "main": "./js/index.js",
  "name": "erlpack",
  "optionalDependencies": {},
  "readme": "# Erlpack\n\nErlpack is a fast encoder and decoder for the Erlang Term Format (version 131) for Python and Javascript.\n\n# Javascript\n\n## Things that can be packed:\n\n- [X] Null\n- [X] Booleans\n- [X] Strings\n- [ ] Atoms\n- [X] Unicode Strings\n- [X] Floats\n- [X] Integers\n- [ ] Longs\n- [ ] Longs over 64 bits\n- [X] Objects\n- [X] Arrays\n- [ ] Tuples\n- [ ] PIDs\n- [ ] Ports\n- [ ] Exports\n- [ ] References\n\n## How to pack:\n```js\nlet erlpack = require(\"erlpack\");\n\npacked = erlpack.pack({'a': true, 'list': ['of', 3, 'things', 'to', 'pack']});\n```\n\n## How to unpack:\nNote: Unpacking requires the binary data be a Uint8Array or Buffer. For those using electron/libchromium see the gotcha below. \n```js\nlet erlpack = require(\"erlpack\");\n\nlet unpacked = null;\nlet packed = new Buffer('', 'binary');\ntry  {\n    unpacked = erlpack.unpack(packed);\n}\ncatch (e) {\n    // got an exception parsing\n}\n```\n\n## Libchromium / Electron Gotcha\nSome versions of libchromium replace the native data type backing TypedArrays with a custom data type called \nblink::WebArrayBuffer. To keep erlpack' dependencies simple this data type is not supported directly. If you're using\nElectron / Libchromium you need to convert the blink::WebArrayBuffer into a node::Buffer before passing to erlpack. You will\nneed to add this code into your native package somewhere:\n```cpp\nv8::Local<v8::Value> ConvertToNodeBuffer(const v8::Local<v8::Object>& blinkArray)\n{\n    if (node::Buffer::HasInstance(blinkArray)) {\n        return blinkArray;\n    }\n    else if (blinkArray->IsArrayBufferView()) {\n        auto byteArray = v8::ArrayBufferView::Cast(*blinkArray);\n        return node::Buffer::Copy(v8::Isolate::GetCurrent(), (const char*)byteArray->Buffer()->GetContents().Data(), byteArray->ByteLength()).ToLocalChecked();\n    }\n    \n    return v8::Local<v8::Primitive>(v8::Null(v8::Isolate::GetCurrent()));\n}\n```\n\nThen in Javascript something like:\n\n```js\nlet packed = NativeUtils.convertToNodeBuffer(new Uint8Array(binaryPayload));\n// unpack now using erlpack.unpack(packed)\n```\n\n# Python\n\n## Things that can be packed:\n\n- [X] None\n- [X] Booleans\n- [X] Strings\n- [X] Atoms\n- [X] Unicode Strings\n- [X] Floats\n- [X] Integers\n- [X] Longs\n- [ ] Longs over 64 bits\n- [X] Dictionaries\n- [X] Lists\n- [X] Tuples\n- [X] User Types (via an encode hook)\n- [ ] PIDs\n- [ ] Ports\n- [ ] Exports\n- [ ] References\n\n## How to pack:\n```py\nfrom erlpack import pack\n\npacked = pack([\"thing\", \"to\", \"pack\"])\n```\n\n## How to unpack:\n```py\nfrom erlpack import unpack\n\nunpacked = unpack(packed)\n```\n\n## How to pack an atom:\n\n```py\nfrom erlpack import Atom, pack\n\npacked = pack(Atom('hello'))\n```\n\n## How to use an encode hook.\n\n```py\nfrom erlpack import ErlangTermEncoder\n\ndef encode_hook(obj):\n    if isinstance(obj, datetime.datetime):\n        return obj.isoformat()\n\nencoder = ErlangTermEncoder(encode_hook=encode_hook)\npacked = encoder.pack(datetime.datetime(2015, 12, 25, 12, 23, 55))\n\n```\n\n## How to make custom types packable.\n\n```py\nfrom erlpack import pack, Atom\n\nclass User(object):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __erlpack__(self):\n        return {\n            Atom('name'): self.name,\n            Atom('age'): self.age\n        }\n\nu = User(name='Jake', age=23)\npacked = pack(u)\n```",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hammerandchisel/erlpack.git"
  },
  "scripts": {
    "install": "node-gyp rebuild",
    "test": "jest"
  },
  "version": "0.1.0"
}
